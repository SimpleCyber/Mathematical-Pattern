import { hslToRgb } from '../utils.js';

export const complexPatterns = {
    mandelbrot: {
        name: "Mandelbrot Set",
        category: "Complex & Sets",
        desc: "The most famous fractal, visualized via complex number escape times.",
        formula: "z(n+1) = z(n)² + c",
        minDepth: 0, maxDepth: 1000, defaultDepth: 100,
        isPixel: true,
        draw: (ctx, canvas, depth, angle, camera) => {
            drawMandelbrot(ctx, canvas, depth, camera);
        }
    },
    julia: {
        name: "Julia Set",
        category: "Complex & Sets",
        desc: "A holomorphic fractal related to the Mandelbrot set.",
        formula: "z(n+1) = z(n)² + fixed c",
        minDepth: 0, maxDepth: 10000, defaultDepth: 100,
        isPixel: true,
        draw: (ctx, canvas, depth, angle, camera) => {
            drawJulia(ctx, canvas, depth, camera);
        }
    },
    bifurcation: {
        name: "Bifurcation Diagram",
        category: "Complex & Sets",
        desc: "Visualizing the route to chaos in the logistic map.",
        formula: "x(n+1) = r * x(n) * (1 - x(n))",
        minDepth: 100, maxDepth: 1000, defaultDepth: 500,
        isPixel: true,
        draw: (ctx, canvas, depth, angle, camera) => {
            drawBifurcation(ctx, canvas, depth, camera);
        }
    },
    pascal: {
        name: "Pascal (Mod 2)",
        category: "Complex & Sets",
        desc: "Pascal's triangle colors by parity, revealing a Sierpinski structure.",
        formula: "nCr mod 2",
        minDepth: 1, maxDepth: 128, defaultDepth: 64,
        isPixel: true,
        draw: (ctx, canvas, depth, angle, camera) => {
            drawPascal(ctx, canvas, depth, camera);
        }
    },
    dejong: {
        name: "De Jong Attractor",
        category: "Complex & Sets",
        desc: "A chaotic strange attractor generated by recursive feedback.",
        formula: "sin(ay)-cos(bx), sin(cx)-cos(dy)",
        minDepth: 1000, maxDepth: 100000, defaultDepth: 50000,
        isPixel: true,
        draw: (ctx, canvas, depth, angle, camera) => {
            drawDeJong(ctx, canvas, depth, camera);
        }
    }
};

function drawMandelbrot(ctx, canvas, iterations, camera) {
    const imageData = ctx.createImageData(canvas.width, canvas.height);
    const w = canvas.width, h = canvas.height;
    for(let i=0; i<w; i++) {
        for(let j=0; j<h; j++) {
            let cx = ((i - camera.x - w / 2) / (camera.zoom * w)) * 4;
            let cy = ((j - camera.y - h / 2) / (camera.zoom * h)) * 4;
            let x = 0, y = 0, n = 0;
            while(x*x + y*y <= 4 && n < iterations) {
                let xt = x*x - y*y + cx;
                y = 2*x*y + cy; x = xt; n++;
            }
            const idx = (i + j * w) * 4;
            const c = n === iterations ? 0 : (n/iterations) * 255;
            imageData.data[idx] = c * 0.5; imageData.data[idx+1] = c; imageData.data[idx+2] = c * 0.8; imageData.data[idx+3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function drawJulia(ctx, canvas, iterations, camera) {
    const imageData = ctx.createImageData(canvas.width, canvas.height);
    const w = canvas.width, h = canvas.height;
    const cx = -0.7, cy = 0.27015;
    for(let i=0; i<w; i++) {
        for(let j=0; j<h; j++) {
            let zx = ((i - camera.x - w / 2) / (camera.zoom * w)) * 3;
            let zy = ((j - camera.y - h / 2) / (camera.zoom * h)) * 3;
            let n = 0;
            while(zx*zx + zy*zy <= 4 && n < iterations) {
                let xt = zx*zx - zy*zy + cx;
                zy = 2*zx*zy + cy; zx = xt; n++;
            }
            const idx = (i + j * w) * 4;
            const c = n === iterations ? 0 : (n/iterations) * 255;
            imageData.data[idx] = c; imageData.data[idx+1] = c*0.4; imageData.data[idx+2] = c*0.9; imageData.data[idx+3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
}

function drawBifurcation(ctx, canvas, points, camera) {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = '#00f2ff';
    for(let i=0; i<w; i++) {
        let r = 2.4 + ((i - camera.x - w/2) / (w * camera.zoom)) * 1.6 + 0.8; 
        if (r < 2.4 || r > 4.0) continue;
        let x = 0.5;
        for(let j=0; j<100; j++) x = r * x * (1 - x);
        for(let j=0; j<points; j++) {
            x = r * x * (1 - x);
            const py = h/2 + camera.y - (x - 0.5) * h * camera.zoom;
            ctx.fillRect(i, py, 1, 1);
        }
    }
}

function drawPascal(ctx, canvas, rows, camera) {
    const w = canvas.width, h = canvas.height;
    const baseSize = Math.min(w, h) / rows;
    const size = baseSize * camera.zoom;
    const centerX = w / 2 + camera.x;
    const startY = 100 + camera.y;
    for(let n=0; n<rows; n++) {
        let c = 1;
        for(let k=0; k<=n; k++) {
            if(c % 2 !== 0) {
                ctx.fillStyle = '#ff0055';
                ctx.fillRect(centerX - (n*size/2) + k*size, startY + n*size, size, size);
            }
            c = c * (n - k) / (k + 1);
        }
    }
}

function drawDeJong(ctx, canvas, points, camera) {
    const w = canvas.width, h = canvas.height;
    let x = 0, y = 0;
    const a = 1.4, b = -2.3, c = 2.4, d = -2.1;
    ctx.fillStyle = 'rgba(0, 242, 255, 0.1)';
    const centerX = w / 2 + camera.x;
    const centerY = h / 2 + camera.y;
    for(let i=0; i<points; i++) {
        let nx = Math.sin(a * y) - Math.cos(b * x);
        let ny = Math.sin(c * x) - Math.cos(d * y);
        x = nx; y = ny;
        ctx.fillRect(centerX + x * 150 * camera.zoom, centerY + y * 150 * camera.zoom, 1, 1);
    }
}
