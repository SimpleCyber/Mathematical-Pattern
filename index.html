<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Fractal Gallery</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #030303;
            --accent: #00f2ff;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-secondary: rgba(255, 255, 255, 0.6);
        }

        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Outfit', sans-serif;
            overflow: hidden;
            display: flex;
        }

        /* Sidebar Navigation */
        .sidebar {
            width: 300px;
            height: 100vh;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(20px);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            padding: 2rem 1.5rem;
            box-sizing: border-box;
            z-index: 100;
        }

        h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 2rem;
            background: linear-gradient(90deg, #00f2ff, #00ff88);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .pattern-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
        }

        .pattern-item {
            padding: 0.8rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            color: var(--text-secondary);
        }

        .pattern-item:hover {
            background: var(--glass);
            color: white;
        }

        .pattern-item.active {
            background: rgba(0, 242, 255, 0.1);
            border-color: rgba(0, 242, 255, 0.3);
            color: var(--accent);
        }

        /* Categories */
        .category {
            margin-bottom: 0.5rem;
        }

        .category-header {
            padding: 0.8rem 1rem;
            background: var(--glass);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            transition: all 0.3s ease;
            border: 1px solid var(--glass-border);
        }

        .category-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .category-header::after {
            content: '›';
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            color: var(--text-secondary);
        }

        .category.open .category-header::after {
            transform: rotate(90deg);
        }

        .category.open .category-header {
            border-color: var(--accent);
            background: rgba(0, 242, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 242, 255, 0.1);
        }

        .category-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding-left: 0.5rem;
        }

        .category.open .category-content {
            max-height: 1000px;
            padding-top: 0.5rem;
        }

        /* Main View */
        .viewport {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
        }

        /* Controls Panel */
        .controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            padding: 1rem 2rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 2rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 150px;
            accent-color: var(--accent);
        }

        .depth-val {
            color: var(--accent);
            font-weight: 600;
            min-width: 20px;
        }

        .stats-overlay {
            position: absolute;
            top: 2rem;
            right: 2rem;
            text-align: right;
            pointer-events: none;
        }

        .stats-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .stats-desc {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            max-width: 200px;
        }
    </style>
</head>
<body>
    <aside class="sidebar">
        <h1>Fractal Gallery</h1>
        <ul class="pattern-list" id="pattern-list">
            <!-- Patterns will be injected here -->
        </ul>
    </aside>

    <main class="viewport">
        <canvas id="canvas"></canvas>
        
        <div class="stats-overlay">
            <div class="stats-title" id="p-name">Pythagoras Tree</div>
            <div class="stats-desc" id="p-desc">A fractal of squares named after the mathematician Pythagoras.</div>
        </div>

        <div class="controls">
            <div class="control-group">
                <span class="control-label">Recursion Depth: <span class="depth-val" id="depth-val">8</span></span>
                <input type="range" id="depth-slider" min="1" max="15" value="8">
            </div>
            <div class="control-group" id="param-group">
                <span class="control-label">Interaction Angle: <span class="depth-val" id="angle-val">45°</span></span>
                <input type="range" id="angle-slider" min="0" max="90" value="45">
            </div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pList = document.getElementById('pattern-list');
        const depthSlider = document.getElementById('depth-slider');
        const depthVal = document.getElementById('depth-val');
        const angleSlider = document.getElementById('angle-slider');
        const angleVal = document.getElementById('angle-val');
        const pName = document.getElementById('p-name');
        const pDesc = document.getElementById('p-desc');

        let currentPattern = 'pythagoras';
        let depth = 8;
        let angle = 45;

        const patterns = {
            pythagoras: {
                name: "Pythagoras Tree",
                category: "Classic Fractals",
                desc: "Squares that branch out based on the Pythagorean theorem.",
                minDepth: 0, maxDepth: 12, defaultDepth: 8,
                draw: (depth, angle) => {
                    const side = Math.min(canvas.width, canvas.height) * 0.15;
                    drawSquare(canvas.width/2 - side/2, canvas.height - 100, side, 0, depth, angle);
                }
            },
            tsquare: {
                name: "T-Square",
                category: "Grids & Subdivisions",
                desc: "Squares centered at the corners of their parent.",
                minDepth: 0, maxDepth: 7, defaultDepth: 5,
                draw: (depth) => {
                    const side = Math.min(canvas.width, canvas.height) * 0.4;
                    drawTSquare(canvas.width/2, canvas.height/2, side, depth);
                }
            },
            htree: {
                name: "H-Tree",
                category: "Classic Fractals",
                desc: "Recursive line segments connected to form the letter 'H'.",
                minDepth: 0, maxDepth: 10, defaultDepth: 6,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.4;
                    drawHTree(canvas.width/2, canvas.height/2, size, true, depth);
                }
            },
            box: {
                name: "Box Fractal",
                category: "Grids & Subdivisions",
                desc: "Subdivided squares forming a cross-like grid pattern.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    drawBox(canvas.width/2 - size/2, canvas.height/2 - size/2, size, depth);
                }
            },
            sierpinski: {
                name: "Sierpiński Triangle",
                category: "Classic Fractals",
                desc: "A triangle subdivided into smaller equilateral triangles.",
                minDepth: 0, maxDepth: 9, defaultDepth: 7,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.8;
                    const h = size * Math.sqrt(3) / 2;
                    drawSierpinski(canvas.width/2, (canvas.height - h)/2, size, depth);
                }
            },
            koch: {
                name: "Koch Snowflake",
                category: "Classic Fractals",
                desc: "A closed curve formed by infinite inward/outward spikes.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    const p1 = { x: canvas.width/2 - size/2, y: canvas.height/2 + size/3 };
                    const p2 = { x: canvas.width/2 + size/2, y: canvas.height/2 + size/3 };
                    const p3 = { x: canvas.width/2, y: canvas.height/2 - size * 0.6 };
                    drawKochLine(p1, p2, depth);
                    drawKochLine(p2, p3, depth);
                    drawKochLine(p3, p1, depth);
                }
            },
            tree: {
                name: "Fractal Tree",
                category: "Classic Fractals",
                desc: "The classic branching structure of organic natural trees.",
                minDepth: 0, maxDepth: 13, defaultDepth: 10,
                draw: (depth, angle) => {
                    const len = canvas.height * 0.25;
                    drawBranch(canvas.width/2, canvas.height - 80, len, -90, depth, angle);
                }
            },
            binary: {
                name: "Binary Tree",
                category: "Classic Fractals",
                desc: "Perfectly symmetrical binary splits at fixed angles.",
                minDepth: 0, maxDepth: 20, defaultDepth: 8,
                draw: (depth) => {
                    drawBinary(canvas.width/2, canvas.height - 100, canvas.height * 0.2, -90, depth);
                }
            },
            hilbert: {
                name: "Hilbert Curve",
                category: "Curves & L-Systems",
                desc: "A space-filling continuous fractal line.",
                minDepth: 0, maxDepth: 7, defaultDepth: 5,
                draw: (depth) => {
                    if (depth === 0) return;
                    const size = Math.min(canvas.width, canvas.height) * 0.8;
                    hilbertX = canvas.width/2 - size/2;
                    hilbertY = canvas.height/2 - size/2;
                    const step = size / (Math.pow(2, depth) - 1);
                    ctx.beginPath();
                    ctx.moveTo(hilbertX, hilbertY);
                    drawHilbert(0, 0, step, depth, 0);
                    ctx.strokeStyle = '#00f2ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            },
            mondrian: {
                name: "Recursive Mondrian",
                category: "Grids & Subdivisions",
                desc: "Randomized rectangular subdivisions in primary colors.",
                minDepth: 0, maxDepth: 7, defaultDepth: 4,
                draw: (depth) => {
                    const w = canvas.width * 0.6;
                    const h = canvas.height * 0.6;
                    drawMondrian(canvas.width/2 - w/2, canvas.height/2 - h/2, w, h, depth);
                }
            },
            vicsek: {
                name: "Vicsek Fractal",
                category: "Grids & Subdivisions",
                desc: "A cross-based subdivision of a square grid.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    drawVicsek(canvas.width/2 - size/2, canvas.height/2 - size/2, size, depth);
                }
            },
            snowflake: {
                name: "Recursive Hexagon",
                category: "Grids & Subdivisions",
                desc: "Star-like patterns branching from a central hexagon.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.15;
                    drawHexagon(canvas.width/2, canvas.height/2, size, depth);
                }
            },
            cantor: {
                name: "Cantor Set",
                category: "Grids & Subdivisions",
                desc: "Middle-third removal from line segments, repeated infinitely.",
                minDepth: 0, maxDepth: 8, defaultDepth: 5,
                draw: (depth) => {
                    const w = canvas.width * 0.8;
                    const x = canvas.width / 2 - w / 2;
                    drawCantor(x, 150, w, depth);
                }
            },
            dragon: {
                name: "Dragon Curve",
                category: "Curves & L-Systems",
                desc: "A paper-folding fractal that creates a complex dragon-like path.",
                minDepth: 0, maxDepth: 14, defaultDepth: 10,
                draw: (depth) => {
                    if (depth === 0) return;
                    const size = Math.min(canvas.width, canvas.height) * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - size/3, canvas.height/2 + size/4);
                    drawDragon(size, 0, depth, 1);
                    ctx.strokeStyle = '#ff0055'; ctx.stroke();
                }
            },
            levy: {
                name: "Lévy C Curve",
                category: "Curves & L-Systems",
                desc: "A self-similar fractal curve formed by 45-degree rotations.",
                minDepth: 0, maxDepth: 14, defaultDepth: 10,
                draw: (depth) => {
                    if (depth === 0) return;
                    const size = Math.min(canvas.width, canvas.height) * 0.4;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - size/2, canvas.height/2 + size/2);
                    drawLevy(size, 0, depth);
                    ctx.strokeStyle = '#00ff88'; ctx.stroke();
                }
            },
            barnsley: {
                name: "Barnsley Fern",
                category: "Space & Nature",
                desc: "A stochastic fractal resembling a natural spleenwort leaf.",
                minDepth: 100, maxDepth: 20000, defaultDepth: 10000,
                draw: (depth) => {
                    drawBarnsley(depth);
                }
            },
            mandelbrot: {
                name: "Mandelbrot Set",
                category: "Complex & Sets",
                desc: "The most famous fractal, visualized via complex number escape times.",
                minDepth: 0, maxDepth: 1000, defaultDepth: 100,
                draw: (depth) => {
                    drawMandelbrot(depth);
                }
            },
            julia: {
                name: "Julia Set",
                category: "Complex & Sets",
                desc: "A holomorphic fractal related to the Mandelbrot set.",
                minDepth: 0, maxDepth: 10000, defaultDepth: 100,
                draw: (depth) => {
                    drawJulia(depth);
                }
            },
            carpet: {
                name: "Sierpiński Carpet",
                category: "Grids & Subdivisions",
                desc: "A square based version of the Sierpiński triangle.",
                minDepth: 0, maxDepth: 5, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    drawCarpet(canvas.width/2 - size/2, canvas.height/2 - size/2, size, depth);
                }
            },
            newton: {
                name: "Newton Fractal",
                category: "Complex & Sets",
                desc: "The basins of attraction for solutions to z^3 - 1 = 0.",
                minDepth: 1, maxDepth: 40, defaultDepth: 20,
                draw: (depth) => {
                    drawNewton(depth);
                }
            },
            bifurcation: {
                name: "Bifurcation Diagram",
                category: "Complex & Sets",
                desc: "Visualizing the route to chaos in the logistic map.",
                minDepth: 100, maxDepth: 1000, defaultDepth: 500,
                draw: (depth) => {
                    drawBifurcation(depth);
                }
            },
            pascal: {
                name: "Pascal (Mod 2)",
                category: "Complex & Sets",
                desc: "Pascal's triangle colors by parity, revealing a Sierpinski structure.",
                minDepth: 1, maxDepth: 128, defaultDepth: 64,
                draw: (depth) => {
                    drawPascal(depth);
                }
            },
            dejong: {
                name: "De Jong Attractor",
                category: "Complex & Sets",
                desc: "A chaotic strange attractor generated by recursive feedback.",
                minDepth: 1000, maxDepth: 100000, defaultDepth: 50000,
                draw: (depth) => {
                    drawDeJong(depth);
                }
            },
            peano: {
                name: "Peano Curve",
                category: "Curves & L-Systems",
                desc: "A classic space-filling curve that tiles a plane.",
                minDepth: 1, maxDepth: 5, defaultDepth: 3,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.8;
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2 - size/2, canvas.height/2 - size/2);
                    drawPeano(canvas.width/2 - size/2, canvas.height/2 - size/2, size, 0, depth);
                    ctx.strokeStyle = '#00f2ff'; ctx.stroke();
                }
            },
            pyramid: {
                name: "Sierpinski Pyramid",
                category: "Grids & Subdivisions",
                desc: "A 2D projection of the 3D Sierpinski tetrahedron.",
                minDepth: 0, maxDepth: 7, defaultDepth: 5,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.6;
                    drawPyramid(canvas.width/2, canvas.height/2 - size/3, size, depth);
                }
            },
            cross: {
                name: "Cross Fractal",
                category: "Grids & Subdivisions",
                desc: "Recursive cross subdivision shaping a geometric square.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    drawCross(canvas.width/2 - size/2, canvas.height/2 - size/2, size, depth);
                }
            },
            nebula: {
                name: "Nebula Cloud",
                category: "Space & Nature",
                desc: "Recursive misty circles simulating deep space gas clouds.",
                minDepth: 0, maxDepth: 8, defaultDepth: 5,
                draw: (depth) => {
                    drawNebula(canvas.width/2, canvas.height/2, canvas.width*0.3, depth);
                }
            },
            galaxy: {
                name: "Galactic Spiral",
                category: "Space & Nature",
                desc: "Logarithmic recursive spiral with glowing star particles.",
                minDepth: 0, maxDepth: 10, defaultDepth: 6,
                draw: (depth) => {
                    drawGalaxy(canvas.width/2, canvas.height/2, 2, 0, depth * 50);
                }
            },
            web: {
                name: "Cosmic Web",
                category: "Space & Nature",
                desc: "Large-scale node connections forming a universal filament structure.",
                minDepth: 0, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    drawWeb(canvas.width/2, canvas.height/2, canvas.width*0.4, depth);
                }
            },
            cluster: {
                name: "Star Cluster",
                category: "Space & Nature",
                desc: "Dense grouping of recursive glowing stars in the void.",
                minDepth: 0, maxDepth: 7, defaultDepth: 5,
                draw: (depth) => {
                    drawCluster(canvas.width/2, canvas.height/2, canvas.width*0.35, depth);
                }
            },
            horizon: {
                name: "Event Horizon",
                category: "Space & Nature",
                desc: "A warped recursive grid spiraling into a central singularity.",
                minDepth: 0, maxDepth: 100, defaultDepth: 40,
                draw: (depth) => {
                    drawHorizon(canvas.width/2, canvas.height/2, canvas.width*0.4, depth);
                }
            },
            apollonian: {
                name: "Apollonian Gasket",
                category: "Cool Stuffs",
                desc: "Mutually tangent circles forming a recursive gasket.",
                minDepth: 1, maxDepth: 6, defaultDepth: 4,
                draw: (depth) => {
                    drawApollonian(depth);
                }
            },
            lorenz: {
                name: "Lorenz Attractor",
                category: "Cool Stuffs",
                desc: "A chaotic system of differential equations.",
                minDepth: 500, maxDepth: 10000, defaultDepth: 5000,
                draw: (depth) => {
                    drawLorenz(depth);
                }
            },
            menger: {
                name: "Menger Sponge (2D)",
                category: "Cool Stuffs",
                desc: "A square based fractal with recursive square removal.",
                minDepth: 0, maxDepth: 5, defaultDepth: 3,
                draw: (depth) => {
                    const size = Math.min(canvas.width, canvas.height) * 0.7;
                    drawMenger(canvas.width/2 - size/2, canvas.height/2 - size/2, size, depth);
                }
            }
        };

        // --- Helper Rendering Functions ---

        function drawSquare(x, y, s, a, d, ang) {
            if(d === 0 || s < 2) return;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(a * Math.PI / 180);
            const hue = 200 + (d * 10);
            ctx.strokeStyle = `hsla(${hue}, 100%, 60%, 0.8)`;
            ctx.shadowBlur = 5; ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.5)`;
            ctx.strokeRect(0, 0, s, -s);
            ctx.restore();

            const s1 = s * Math.cos(ang * Math.PI / 180);
            const s2 = s * Math.sin(ang * Math.PI / 180);
            const x1 = x + Math.cos((a - 90) * Math.PI / 180) * s;
            const y1 = y + Math.sin((a - 90) * Math.PI / 180) * s;
            const x2 = x1 + Math.cos((a - 90 + ang) * Math.PI / 180) * s1;
            const y2 = y1 + Math.sin((a - 90 + ang) * Math.PI / 180) * s1;

            drawSquare(x1, y1, s1, a - ang, d-1, ang);
            drawSquare(x2, y2, s2, a + (90 - ang), d-1, ang);
        }

        function drawTSquare(x, y, s, d) {
            if(d === 0) return;
            ctx.strokeStyle = '#00ff88';
            ctx.strokeRect(x - s/2, y - s/2, s, s);
            const ns = s/2;
            drawTSquare(x-ns, y-ns, ns, d-1);
            drawTSquare(x+ns, y-ns, ns, d-1);
            drawTSquare(x-ns, y+ns, ns, d-1);
            drawTSquare(x+ns, y+ns, ns, d-1);
        }

        function drawHTree(x, y, s, h, d) {
            if(d === 0) return;
            ctx.strokeStyle = '#f200ff';
            ctx.beginPath();
            if(h) {
                ctx.moveTo(x - s/2, y); ctx.lineTo(x + s/2, y);
                ctx.stroke();
                drawHTree(x - s/2, y, s/Math.sqrt(2), false, d-1);
                drawHTree(x + s/2, y, s/Math.sqrt(2), false, d-1);
            } else {
                ctx.moveTo(x, y - s/2); ctx.lineTo(x, y + s/2);
                ctx.stroke();
                drawHTree(x, y - s/2, s/Math.sqrt(2), true, d-1);
                drawHTree(x, y + s/2, s/Math.sqrt(2), true, d-1);
            }
        }

        function drawBox(x, y, s, d) {
            if(d === 1) {
                ctx.strokeStyle = '#00f2ff';
                ctx.strokeRect(x, y, s, s);
                return;
            }
            const ns = s / 3;
            drawBox(x, y, ns, d-1);
            drawBox(x + 2*ns, y, ns, d-1);
            drawBox(x + ns, y + ns, ns, d-1);
            drawBox(x, y + 2*ns, ns, d-1);
            drawBox(x + 2*ns, y + 2*ns, ns, d-1);
        }

        function drawSierpinski(x, y, s, d) {
            if(d === 0) return;
            const h = s * Math.sqrt(3) / 2;
            ctx.strokeStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(x, y); ctx.lineTo(x + s/2, y + h); ctx.lineTo(x-s/2, y+h); ctx.closePath(); ctx.stroke();
            if(d > 1) {
                drawSierpinski(x, y, s/2, d-1);
                drawSierpinski(x - s/4, y + h/2, s/2, d-1);
                drawSierpinski(x + s/4, y + h/2, s/2, d-1);
            }
        }

        function drawKochLine(p1, p2, d) {
            if(d === 0) {
                ctx.strokeStyle = '#00ffcc';
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                return;
            }
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const a = { x: p1.x + dx/3, y: p1.y + dy/3 };
            const c = { x: p1.x + 2*dx/3, y: p1.y + 2*dy/3 };
            const angle = -Math.PI / 3;
            const b = {
                x: a.x + (c.x - a.x) * Math.cos(angle) - (c.y - a.y) * Math.sin(angle),
                y: a.y + (c.x - a.x) * Math.sin(angle) + (c.y - a.y) * Math.cos(angle)
            };
            drawKochLine(p1, a, d-1);
            drawKochLine(a, b, d-1);
            drawKochLine(b, c, d-1);
            drawKochLine(c, p2, d-1);
        }

        function drawBranch(x, y, l, a, d, ang) {
            if(d === 0) return;
            const x2 = x + Math.cos(a * Math.PI / 180) * l;
            const y2 = y + Math.sin(a * Math.PI / 180) * l;
            ctx.strokeStyle = `hsla(${200 + d * 10}, 80%, 60%, ${d/8})`;
            ctx.lineWidth = d * 0.5;
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x2, y2); ctx.stroke();
            drawBranch(x2, y2, l * 0.75, a - ang, d-1, ang);
            drawBranch(x2, y2, l * 0.75, a + ang, d-1, ang);
        }

        function drawBinary(x, y, l, a, d) {
            if(d === 0) return;
            const x2 = x + Math.cos(a * Math.PI / 180) * l;
            const y2 = y + Math.sin(a * Math.PI / 180) * l;
            ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x2, y2); ctx.stroke();
            drawBinary(x2, y2, l * 0.7, a - 30, d-1);
            drawBinary(x2, y2, l * 0.7, a + 30, d-1);
        }

        let hilbertX, hilbertY;
        function drawHilbert(x, y, step, d, type) {
            if(d === 0) return;
            if(type === 0) {
                drawHilbert(x, y, step, d-1, 1);
                hLine(0, 1, step);
                drawHilbert(x, y, step, d-1, 0);
                hLine(1, 0, step);
                drawHilbert(x, y, step, d-1, 0);
                hLine(0, -1, step);
                drawHilbert(x, y, step, d-1, 3);
            } else if(type === 1) {
                drawHilbert(x, y, step, d-1, 0);
                hLine(1, 0, step);
                drawHilbert(x, y, step, d-1, 1);
                hLine(0, 1, step);
                drawHilbert(x, y, step, d-1, 1);
                hLine(-1, 0, step);
                drawHilbert(x, y, step, d-1, 2);
            } else if(type === 2) {
                drawHilbert(x, y, step, d-1, 3);
                hLine(0, -1, step);
                drawHilbert(x, y, step, d-1, 2);
                hLine(-1, 0, step);
                drawHilbert(x, y, step, d-1, 2);
                hLine(0, 1, step);
                drawHilbert(x, y, step, d-1, 1);
            } else {
                drawHilbert(x, y, step, d-1, 2);
                hLine(-1, 0, step);
                drawHilbert(x, y, step, d-1, 3);
                hLine(0, -1, step);
                drawHilbert(x, y, step, d-1, 3);
                hLine(1, 0, step);
                drawHilbert(x, y, step, d-1, 0);
            }
        }
        function hLine(dx, dy, s) {
            hilbertX += dx * s; hilbertY += dy * s; ctx.lineTo(hilbertX, hilbertY);
        }

        function drawMondrian(x, y, w, h, d) {
            if(d === 0) {
                const colors = ['#f00', '#ff0', '#00f', '#fff', '#000'];
                ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.strokeRect(x, y, w, h);
                return;
            }
            if(w > h) {
                const split = 0.3 + Math.random() * 0.4;
                drawMondrian(x, y, w * split, h, d-1);
                drawMondrian(x + w * split, y, w * (1-split), h, d-1);
            } else {
                const split = 0.3 + Math.random() * 0.4;
                drawMondrian(x, y, w, h * split, d-1);
                drawMondrian(x, y + h * split, w, h * (1-split), d-1);
            }
        }

        function drawVicsek(x, y, s, d) {
            if(d === 1) {
                ctx.strokeStyle = '#00ff88'; ctx.strokeRect(x, y, s, s);
                return;
            }
            const ns = s/3;
            drawVicsek(x + ns, y, ns, d-1);
            drawVicsek(x, y + ns, ns, d-1);
            drawVicsek(x + ns, y + ns, ns, d-1);
            drawVicsek(x + 2*ns, y + ns, ns, d-1);
            drawVicsek(x + ns, y + 2*ns, ns, d-1);
        }

        function drawHexagon(x, y, s, d) {
            if(d === 0) return;
            ctx.strokeStyle = '#00f2ff';
            ctx.beginPath();
            for(let i=0; i<6; i++) {
                const a = i * Math.PI / 3;
                const px = x + Math.cos(a) * s;
                const py = y + Math.sin(a) * s;
                if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.closePath(); ctx.stroke();
            const ns = s * 0.45;
            for(let i=0; i<6; i++) {
                const a = i * Math.PI / 3;
                drawHexagon(x + Math.cos(a) * s, y + Math.sin(a) * s, ns, d-1);
            }
        }

        function drawCantor(x, y, w, d) {
            if(d === 0) return;
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + w, y); ctx.stroke();
            if(d > 1) {
                drawCantor(x, y + 40, w / 3, d-1);
                drawCantor(x + 2*w/3, y + 40, w / 3, d-1);
            }
        }

        function drawDragon(l, a, d, sign) {
            if(d === 0) {
                const x = ctx.currentX || canvas.width/2;
                const y = ctx.currentY || canvas.height/2;
                const nx = x + Math.cos(a * Math.PI / 180) * l;
                const ny = y + Math.sin(a * Math.PI / 180) * l;
                ctx.lineTo(nx, ny);
                ctx.currentX = nx; ctx.currentY = ny;
                return;
            }
            const nl = l / Math.sqrt(2);
            drawDragon(nl, a + 45 * sign, d - 1, 1);
            drawDragon(nl, a - 45 * sign, d - 1, -1);
        }

        function drawLevy(l, a, d) {
            if(d === 0) {
                const x = ctx.currentX || canvas.width/2 - 100;
                const y = ctx.currentY || canvas.height/2 + 100;
                const nx = x + Math.cos(a * Math.PI / 180) * l;
                const ny = y + Math.sin(a * Math.PI / 180) * l;
                ctx.lineTo(nx, ny);
                ctx.currentX = nx; ctx.currentY = ny;
                return;
            }
            const nl = l / Math.sqrt(2);
            drawLevy(nl, a + 45, d - 1);
            drawLevy(nl, a - 45, d - 1);
        }

        function drawBarnsley(depth) {
            let x = 0, y = 0;
            ctx.fillStyle = '#00ff88';
            for(let i=0; i<depth; i++) {
                const r = Math.random();
                let nx, ny;
                if(r < 0.01) { nx = 0; ny = 0.16 * y; }
                else if(r < 0.86) { nx = 0.85 * x + 0.04 * y; ny = -0.04 * x + 0.85 * y + 1.6; }
                else if(r < 0.93) { nx = 0.2 * x - 0.26 * y; ny = 0.23 * x + 0.22 * y + 1.6; }
                else { nx = -0.15 * x + 0.28 * y; ny = 0.26 * x + 0.24 * y + 0.44; }
                x = nx; y = ny;
                ctx.fillRect(canvas.width/2 + x * 60, canvas.height - y * 60 - 20, 1, 1);
            }
        }

        function drawMandelbrot(iterations) {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const w = canvas.width, h = canvas.height;
            for(let i=0; i<w; i++) {
                for(let j=0; j<h; j++) {
                    let cx = (i - w/2) * (4/w);
                    let cy = (j - h/2) * (4/h);
                    let x = 0, y = 0, n = 0;
                    while(x*x + y*y <= 4 && n < iterations) {
                        let xt = x*x - y*y + cx;
                        y = 2*x*y + cy; x = xt; n++;
                    }
                    const idx = (i + j * w) * 4;
                    const c = n === iterations ? 0 : (n/iterations) * 255;
                    imageData.data[idx] = c * 0.5; imageData.data[idx+1] = c; imageData.data[idx+2] = c * 0.8; imageData.data[idx+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function drawJulia(iterations) {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const w = canvas.width, h = canvas.height;
            const cx = -0.7, cy = 0.27015;
            for(let i=0; i<w; i++) {
                for(let j=0; j<h; j++) {
                    let zx = (i - w/2) * (3/w);
                    let zy = (j - h/2) * (3/h);
                    let n = 0;
                    while(zx*zx + zy*zy <= 4 && n < iterations) {
                        let xt = zx*zx - zy*zy + cx;
                        zy = 2*zx*zy + cy; zx = xt; n++;
                    }
                    const idx = (i + j * w) * 4;
                    const c = n === iterations ? 0 : (n/iterations) * 255;
                    imageData.data[idx] = c; imageData.data[idx+1] = c*0.4; imageData.data[idx+2] = c*0.9; imageData.data[idx+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function drawCarpet(x, y, s, d) {
            if(d === 0) { ctx.fillStyle = '#00f2ff'; ctx.fillRect(x, y, s, s); return; }
            const ns = s / 3;
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    if(i===1 && j===1) continue;
                    drawCarpet(x + i*ns, y + j*ns, ns, d-1);
                }
            }
        }

        function drawCross(x, y, s, d) {
            if (d === 1) { ctx.strokeStyle = '#fff'; ctx.strokeRect(x, y, s, s); return; }
            const ns = s / 3;
            drawCross(x + ns, y, ns, d-1);
            drawCross(x, y + ns, ns, d-1);
            drawCross(x + ns, y + ns, ns, d-1);
            drawCross(x + 2*ns, y + ns, ns, d-1);
            drawCross(x + ns, y + 2*ns, ns, d-1);
        }

        function drawNewton(iterations) {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const w = canvas.width, h = canvas.height;
            for(let i=0; i<w; i++) {
                for(let j=0; j<h; j++) {
                    let x = (i - w/2) * (4/w);
                    let y = (j - h/2) * (4/h);
                    let n = 0;
                    while(n < iterations) {
                        let r2 = x*x + y*y;
                        if(r2 === 0) break;
                        let nx = (2*x + (x*x - y*y)/(r2*r2))/3;
                        let ny = (2*y - (2*x*y)/(r2*r2))/3;
                        if(Math.abs(nx-x) < 0.001 && Math.abs(ny-y) < 0.001) break;
                        x = nx; y = ny; n++;
                    }
                    const idx = (i + j * w) * 4;
                    const h = (Math.atan2(y, x) + Math.PI) / (2 * Math.PI) * 360;
                    const rgb = hslToRgb(h / 360, 0.8, 0.5);
                    imageData.data[idx] = rgb[0]; imageData.data[idx+1] = rgb[1]; imageData.data[idx+2] = rgb[2]; imageData.data[idx+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function drawBifurcation(points) {
            const w = canvas.width, h = canvas.height;
            ctx.fillStyle = '#00f2ff';
            for(let i=0; i<w; i++) {
                let r = 2.4 + (i/w) * 1.6;
                let x = 0.5;
                for(let j=0; j<100; j++) x = r * x * (1 - x); // warmup
                for(let j=0; j<points; j++) {
                    x = r * x * (1 - x);
                    ctx.fillRect(i, h - x * h, 1, 1);
                }
            }
        }

        function drawPascal(rows) {
            const size = Math.min(canvas.width, canvas.height) / rows;
            for(let n=0; n<rows; n++) {
                let c = 1;
                for(let k=0; k<=n; k++) {
                    if(c % 2 !== 0) {
                        ctx.fillStyle = '#ff0055';
                        ctx.fillRect(canvas.width/2 - (n*size/2) + k*size, 100 + n*size, size, size);
                    }
                    c = c * (n - k) / (k + 1);
                }
            }
        }

        function drawDeJong(points) {
            let x = 0, y = 0;
            const a = 1.4, b = -2.3, c = 2.4, d = -2.1;
            ctx.fillStyle = 'rgba(0, 242, 255, 0.1)';
            for(let i=0; i<points; i++) {
                let nx = Math.sin(a * y) - Math.cos(b * x);
                let ny = Math.sin(c * x) - Math.cos(d * y);
                x = nx; y = ny;
                ctx.fillRect(canvas.width/2 + x * 150, canvas.height/2 + y * 150, 1, 1);
            }
        }

        function drawPeano(x, y, s, a, d) {
            if(d === 0) return;
            const ns = s / 3;
            // Simplified Peano structure
            drawPeano(x, y, ns, a, d-1);
            drawPeano(x + ns, y, ns, a, d-1);
            drawPeano(x + 2*ns, y, ns, a, d-1);
            drawPeano(x + 2*ns, y + ns, ns, a, d-1);
            drawPeano(x + ns, y + ns, ns, a, d-1);
            drawPeano(x, y + ns, ns, a, d-1);
            drawPeano(x, y + 2*ns, ns, a, d-1);
            drawPeano(x + ns, y + 2*ns, ns, a, d-1);
            drawPeano(x + 2*ns, y + 2*ns, ns, a, d-1);
        }

        function drawPyramid(x, y, s, d) {
            if(d === 0) {
                ctx.strokeStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(x, y); ctx.lineTo(x + s/2, y + s); ctx.lineTo(x - s/2, y + s); ctx.closePath(); ctx.stroke();
                return;
            }
            const ns = s / 2;
            drawPyramid(x, y, ns, d-1);
            drawPyramid(x - ns/2, y + ns, ns, d-1);
            drawPyramid(x + ns/2, y + ns, ns, d-1);
            drawPyramid(x, y + ns/2, ns, d-1);
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hueToRgb(p, q, h + 1/3);
                g = hueToRgb(p, q, h);
                b = hueToRgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function hueToRgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        function drawNebula(x, y, r, d) {
            if (d === 0) return;
            const hue = 260 + (Math.random() * 60);
            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.05)`;
            ctx.shadowBlur = 40; ctx.shadowColor = `hsla(${hue}, 100%, 50%, 0.2)`;
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            for(let i=0; i<3; i++) {
                const nr = r * 0.6;
                const na = Math.random() * Math.PI * 2;
                drawNebula(x + Math.cos(na) * r * 0.5, y + Math.sin(na) * r * 0.5, nr, d-1);
            }
        }

        function drawGalaxy(x, y, r, a, dots) {
            ctx.fillStyle = '#fff';
            for(let i=0; i<dots; i++) {
                const angle = 0.1 * i;
                const dist = 5 * angle;
                const hue = 200 + (i % 100);
                ctx.shadowBlur = 5; ctx.shadowColor = `hsla(${hue}, 100%, 70%, 0.8)`;
                ctx.fillStyle = `hsla(${hue}, 100%, 70%, 1)`;
                const px = x + Math.cos(angle) * dist;
                const py = y + Math.sin(angle) * dist;
                ctx.fillRect(px, py, 1.5, 1.5);
                // Secondary arm
                const px2 = x + Math.cos(angle + Math.PI) * dist;
                const py2 = y + Math.sin(angle + Math.PI) * dist;
                ctx.fillRect(px2, py2, 1.5, 1.5);
            }
        }

        function drawWeb(x, y, s, d) {
            if(d === 0) return;
            const nodes = [];
            for(let i=0; i<5; i++) {
                nodes.push({
                    x: x + (Math.random() - 0.5) * s,
                    y: y + (Math.random() - 0.5) * s
                });
            }
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
            ctx.lineWidth = d * 0.2;
            ctx.beginPath();
            nodes.forEach((p, i) => {
                nodes.forEach((p2, j) => {
                    if(i !== j) { ctx.moveTo(p.x, p.y); ctx.lineTo(p2.x, p2.y); }
                });
            });
            ctx.stroke();
            nodes.forEach(p => drawWeb(p.x, p.y, s * 0.4, d-1));
        }

        function drawCluster(x, y, s, d) {
            if(d === 0) return;
            for(let i=0; i<8; i++) {
                const px = x + (Math.random() - 0.5) * s;
                const py = y + (Math.random() - 0.5) * s;
                const size = Math.random() * 2;
                const hue = 180 + Math.random() * 100;
                ctx.fillStyle = `hsla(${hue}, 100%, 80%, ${d/7})`;
                ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle;
                ctx.fillRect(px, py, size, size);
                if(d > 1) drawCluster(px, py, s * 0.3, d-1);
            }
        }

        function drawHorizon(cx, cy, r, d) {
            if(d === 0) return;
            ctx.strokeStyle = `rgba(255, 100, 255, ${d/10})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<12; i++) {
                const a = (i / 12) * Math.PI * 2;
                const x1 = cx + Math.cos(a) * r;
                const y1 = cy + Math.sin(a) * r;
                const x2 = cx + Math.cos(a + 0.5) * r * 0.8;
                const y2 = cy + Math.sin(a + 0.5) * r * 0.8;
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
            }
            ctx.stroke();
            drawHorizon(cx, cy, r * 0.8, d-1);
        }

        function drawApollonian(d) {
            const r = Math.min(canvas.width, canvas.height) * 0.4;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            function recursiveCircle(x, y, rad, depth) {
                if (depth === 0) return;
                ctx.strokeStyle = `hsla(${180 + depth * 20}, 100%, 60%, 0.8)`;
                ctx.beginPath(); ctx.arc(x, y, rad, 0, Math.PI * 2); ctx.stroke();
                
                const nr = rad / (1 + 2/Math.sqrt(3));
                for(let i=0; i<3; i++) {
                    const angle = i * Math.PI * 2 / 3 - Math.PI/2;
                    recursiveCircle(x + Math.cos(angle) * (rad - nr), y + Math.sin(angle) * (rad - nr), nr, depth - 1);
                }
                // Central circle
                recursiveCircle(x, y, rad - 2 * (rad - nr), depth - 1);
            }
            recursiveCircle(cx, cy, r, d);
        }

        function drawLorenz(iterations) {
            let x = 0.1, y = 0, z = 0;
            const sigma = 10, rho = 28, beta = 8/3;
            const dt = 0.01;
            ctx.beginPath();
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 0.5;
            for(let i=0; i<iterations; i++) {
                let dx = sigma * (y - x) * dt;
                let dy = (x * (rho - z) - y) * dt;
                let dz = (x * y - beta * z) * dt;
                x += dx; y += dy; z += dz;
                const px = canvas.width/2 + x * 15;
                const py = canvas.height/2 + (y - z) * 10;
                if(i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }

        function drawMenger(x, y, s, d) {
            if(d === 0) {
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(x, y, s, s);
                return;
            }
            const ns = s / 3;
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    if(i === 1 && j === 1) continue;
                    drawMenger(x + i*ns, y + j*ns, ns, d-1);
                }
            }
        }

        // --- Core Application Logic ---

        function init() {
            resize();
            const groups = {};
            Object.keys(patterns).forEach(key => {
                const cat = patterns[key].category || 'Uncategorized';
                if (!groups[cat]) groups[cat] = [];
                groups[cat].push({ key, ...patterns[key] });
            });

            pList.innerHTML = '';
            Object.keys(groups).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'category' + (cat === patterns[currentPattern].category ? ' open' : '');
                
                const header = document.createElement('div');
                header.className = 'category-header';
                header.textContent = cat;
                header.onclick = () => catDiv.classList.toggle('open');
                
                const content = document.createElement('div');
                content.className = 'category-content';
                
                groups[cat].forEach(p => {
                    const li = document.createElement('div');
                    li.className = 'pattern-item' + (p.key === currentPattern ? ' active' : '');
                    li.textContent = p.name;
                    li.onclick = (e) => {
                        e.stopPropagation();
                        selectPattern(p.key);
                    };
                    content.appendChild(li);
                });
                
                catDiv.appendChild(header);
                catDiv.appendChild(content);
                pList.appendChild(catDiv);
            });
            render();
        }

        function selectPattern(key) {
            currentPattern = key;
            const p = patterns[key];
            pName.textContent = p.name;
            pDesc.textContent = p.desc;
            
            const min = p.minDepth !== undefined ? p.minDepth : 1;
            depthSlider.min = min;
            depthSlider.max = p.maxDepth || 10;
            
            // Use default if available, otherwise stay close to current if valid
            depth = p.defaultDepth || Math.max(min, Math.min(depth, p.maxDepth));
            depthSlider.value = depth;
            
            document.querySelectorAll('.pattern-item').forEach(el => {
                el.classList.toggle('active', el.textContent === p.name);
            });

            const hasAngle = ['pythagoras', 'tree'].includes(key);
            document.getElementById('param-group').style.display = hasAngle ? 'flex' : 'none';

            render();
        }

        function resize() {
            canvas.width = window.innerWidth - 300;
            canvas.height = window.innerHeight;
            render();
        }

        let renderPending = false;
        function render() {
            if (renderPending) return;
            renderPending = true;
            
            requestAnimationFrame(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.currentX = undefined; ctx.currentY = undefined;
                depthVal.textContent = depth;
                angleVal.textContent = angle + '°';
                patterns[currentPattern].draw(depth, angle);
                ctx.restore();
                renderPending = false;
            });
        }

        depthSlider.oninput = (e) => { depth = parseInt(e.target.value); render(); };
        angleSlider.oninput = (e) => { angle = parseInt(e.target.value); render(); };
        window.onresize = resize;

        init();
    </script>
</body>
</html>
